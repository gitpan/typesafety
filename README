typesafety version 0.03
=======================

typesafety.pm - compile-time type usage static analysis 

This software is alpha - some things work, it might even be useful, but key things
are still lacking.

SYNOPSIS:

  package main;
  use typesafety;

  # use typesafety 'summary';

  my FooBar $foo :typed; # alternate syntax:    declare FooBar => my $a;
  my FooBar $bar :typed; # establish type-checked variables
  my BazQux $baz :typed; # my <type/package> <variable> :typed;

  $foo = new FooBar;     # this is okey, because $foo holds FooBars
  $bar = $foo;           # this is okey, because $bar also holds FooBars
  # $foo = 10;           # this would throw an error - 10 is not a FooBar
  # $baz = $foo;         # not allowed - FooBar isn't a BazQux
  $foo = $baz;           # is allowed -  BazQux is a FooBar because of inheritance
  $bar = $foo->foo();    # this is okey, as FooBar::foo() returns FooBars also

  typesafety::check();   # perform type check static analysis

  #

  package FooBar;
  use typesafety;

  # unneeded - new() defaults to prototype to return same type as package
  # proto 'new', returns => 'FooBar'; 

  proto 'foo', returns => 'FooBar'; 
  # proto 'methodname', returns => 'FooBar', takes => 'Type', 'Type', 'Type', undef;


  sub new {
    my $type = shift; $type = ref $type if ref $type;
    bless [], $type;
  }

  sub foo { my $me = shift; return $me->new(); } 

  #

  package BazQux;
  use typesafety;
  @ISA = 'FooBar';

  # other things are checked as well - bless, return.
  # this documentation is out of date with reguards to the documentation in
  # the module, but it should give you the general idea.

DESCRIPTION:

Prevents you from mistakenly bathing cats.

Failure to keep track what kind of data is in a given variable or returned 
from a given method is an epic source of confusion and frustration during
debugging. 

Given a ->get_pet() method, you might try to bathe the output. If it always
a dog during testing, everything is fine, but sooner or later, you're
going to get a cat, and that can be rather bloody.

Welcome to Type Safety. Type Safety means knowing what kind of data you
have (atleast in general - it may be a subclass of the type you know
you have). Because you always know what kind of data it is, you see in
advance when you try to use something too generic (like a pet) where you
want something more specific (like a dog, or atleast a pet that implements
the "washable" interface).

Think of Type Safety as a new kind of variable scoping -
instead of scoping where the variables can be seen from, you're scoping
what kind of data they might contain.


INSTALLATION

To install this module type the following:

   perl Makefile.PL
   make
   make test
   make install

DEPENDENCIES

This module requires these other modules and libraries:

  B::Generate

COPYRIGHT AND LICENCE

Distribute under the same terms as Perl itself.

Copyright (C) 2003 Scott Walters, scott@slowass.net

